![[Pasted image 20240330200735.png]]
![[Pasted image 20240330200815.png]]
![[Pasted image 20240330201033.png]]

### Exception Sources
![[Pasted image 20240330201350.png]]

### Exception Hierarchy
![[Pasted image 20240330204027.png]]
- All exceptions are subclasses of the build-in class `Throwable`
- `Throwable` contains two immediate sub-classes:
![[Pasted image 20240330203620.png]]



### Java Built-In Exceptions

The default java.lang package provides several exception classes, all sub-classing the `RuntimeException` class.

#### 1. Unchecked Exceptions
- These are the exceptions that are not checked at compile time and checked by the JVM.
- The compiler does not check if a method handles or throws there exceptions.

![[Pasted image 20240330202043.png]]

#### 2. Checked Exceptions
- These are the exceptions that are checked at compile time by the java compiler.
-  If some code within a method throws a checked exception,then the method must either handle the exception or it must specify the exception using throws keyword.

![[Pasted image 20240330202351.png]]

### Exception Constructs
 Five constructs are used in exception handling:

![[Pasted image 20240330203219.png]]
![[Pasted image 20240330203237.png]]

### Exception Handling Block

![[Pasted image 20240330214546.png]]

### Uncaught Exception

![[Pasted image 20240330214619.png]]

As we have not provided any exception handler, the exception is caught by the **default exception handler** provided by the Java run-time system.

#### Default exception handler
- displays a string describing the exception
- prints the **stack trace** from the point where the exception occurred
- terminates the program

#### Stack trace display
- The stack trace displayed by the default error handler shows the sequence of method invocations that led up to the error.
- A record of the active stack frames generated by the execution of a program.
- Used for debugging.

```java
class Exce
{
	static void subroutine()
	{
		int d = 0;
		int a = 10/d;
	}
	public static void main(String args[])
	{
		Exce.subroutine();
	}
}
```

This will throw an `ArithmeticException` because it's trying to divide by zero (`d = 0` and `a = 10 / d`). When you run this code, you'll get a stack trace similar to the following:

```css
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at Exce.subroutine(Exce.java:4)
    at Exce.main(Exce.java:8)
```

This stack trace indicates that the `ArithmeticException` occurred in the `subroutine` method at line 4, which was called from the `main` method at line 8.

### Exception Handling -- Working
![[Pasted image 20240330215701.png]]
#### Try and Catch
- `try` surrounds any code we want to monitor for exceptions.
	![[Pasted image 20240330215815.png]]
- `catch` specifies which exception we want to handle and how.
	![[Pasted image 20240330215841.png]]
	- The exception is handled and the execution resumes

### Exception Display
![[Pasted image 20240330220235.png]]

### Multiple Catch Clauses
![[Pasted image 20240330220359.png]]

#### Order of catch blocks are important
![[Pasted image 20240330221646.png]]
```java
class OrderOfException {
    public static void main(String args[]) {
        try {
            int a = 0;
            int b = 42 / a;
        } catch (Exception e) {
            System.out.println("Generic Exception Catch");
        } catch (ArithmeticException e) {
            System.out.println("This block is never reached");
        }
    }
}
```

```css
OrderOfException.java:8: error: exception ArithmeticException has already been caught
        } catch (ArithmeticException e) {
          ^
1 error
```

```java
class OrderOfException {
    public static void main(String args[]) {
        try {
            int a = 0;
            int b = 42 / a;
        } catch (ArithmeticException e) {
            System.out.println("This block is now reached");
        } catch (Exception e) {
            System.out.println("Generic Exception Catch");
        }
    }
}
```

```css
This block is now reached
```

### Nested Try Statements
![[Pasted image 20240330222150.png]]
![[Pasted image 20240330222216.png]]

### Throwing Exceptions
![[Pasted image 20240330222405.png]]
![[Pasted image 20240330222423.png]]

### Getting Throwable Instance

In Java, there are several ways to obtain an instance of a `Throwable`, which is the superclass of all errors and exceptions in the Java language. Here are two common ways:

1. **Throwing an Exception:** You can create and throw a new instance of an exception or error.  All Java built-in exceptions have at least two constructors: *one without parameters* and another *with one String parameter*:
For example:
```java
throw new RuntimeException("This is a runtime exception");
```

   In this case, a new `RuntimeException` instance is created and thrown, which can later be caught and handled by a try-catch block.

2. **Catching an Exception:** You can catch an exception or error that has been thrown elsewhere in your code or by another method. For example:

```java
try {
   // Some code that may throw an exception
} catch (Exception e) {
   // Handle the exception
}
   ```

   In this case, if an exception is thrown inside the try block, the catch block will catch it, and you will have an instance of the exception in the variable `e`.

These are just two common ways to obtain a `Throwable` instance in Java. There are other ways, such as using reflection to create an instance or obtaining an instance from a method that returns a `Throwable`.

![[Pasted image 20240330223943.png]]

### throws statement
![[Pasted image 20240330231847.png]]
![[Pasted image 20240331001235.png]]
![[Pasted image 20240331001318.png]]

```java
public class DemoThrows {
    public static void main(String[] args) {
        try {
            // Call a method(s) that throws an exception
            riskyMethod();
            anotherRiskyMethod();
        } catch (Exception e) {
            System.out.println("Caught exception(s): " + e);
        }
    }

    // A method that declares it may throw an exception
    static void riskyMethod() throws Exception {
        // Simulate an exception being thrown
        throw new Exception("Something went wrong!");
    }

    static void anotherRiskyMethod() throws Exception {
        throw new Exception("This will be skipped; not printed");
    }
}
```

```css
Caught exception(s): java.lang.Exception: Something went wrong!
```

A method that declares itself `throws` *may* throw an exception.

### finally block
![[Pasted image 20240330232300.png]]
![[Pasted image 20240330232320.png]]
![[Pasted image 20240330232335.png]]
![[Pasted image 20240330232607.png]]

![[Pasted image 20240330233948.png]]


![[Pasted image 20240330234246.png]]
![[Pasted image 20240330234304.png]]

### User Defined Exceptions
![[Pasted image 20240330234433.png]]

```java
class MyCustomException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}
```

You can then throw and catch instances of `MyCustomException` like any other exception in Java.

```java
public class CustomExceptionExample {
    public static void main(String[] args) {
        try {
            validateInput(10);
            validateInput(200); // This will throw an exception
        } catch (MyCustomException e) {
            System.out.println("Caught an exception: " + e.getMessage());
        }
    }

    public static void validateInput(int number) throws MyCustomException {
        if (number > 100) {
            throw new MyCustomException("Number is too large: " + number);
        }
        System.out.println("Number is valid: " + number);
    }
}
```

```css
Number is valid: 10
Caught an exception: Number is too large: 200
```

#### Methods defined by Throwable class

All user exceptions have the methods defined by the Throwable class:

