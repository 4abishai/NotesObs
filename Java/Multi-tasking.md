
Reduce response time.

## Types

#### 1. Process-Based

- Executing several tasks simultaneously where each task is a separate independent process.
- This type of multitasking is best suitable at "os level".
#### 2. Thread-Based

- Executing several tasks simultaneously where each task is a separate independent part of the same program.
- Each independent part is called a "Thread".

# Multi-threading

## Ways to define, instantiate and start a new Thread

### Extending thread class

![[Pasted image 20240322023900.png]]

If multiple Threads are waiting to execute then which Thread will execute first is decided by **Thread Scheduler** which is part of JVM. Which algorithm or behavior followed by Thread Scheduler we can't expect exactly, as it is the JVM **vendor dependent**. Hence in multithreading examples *we can't expect exact execution order and exact output*.

![[Pasted image 20240322024118.png]]

#### Diff. between t.start() and t.run() methods

![[Pasted image 20240322024304.png]]

#### Importance of Thread class start() method

![[Pasted image 20240322024505.png]]

![[Pasted image 20240322024526.png]]

#### What happens If we are not overriding run() method

![[Pasted image 20240322024624.png]]

#### Overloading of the run() method.

![[Pasted image 20240322024814.png]]

#### Overriding of the start() method.

![[Pasted image 20240322024919.png]]

We must then call super( ) in order to create thread here.

![[Pasted image 20240322025115.png]]

#### Life cycle of the Thread

![[Pasted image 20240322025257.png]]

#### Restarting same thread

After starting a `Thread` we are not allowed to restart the same `Thread` once again otherwise we will get runtime exception saying `IllegalThreadStateException`.

![[Pasted image 20240322025436.png]]


### Implementing Runn-able interface

![[Pasted image 20240322030403.png]]
![[Pasted image 20240322030420.png]]

We can't expect exact order of output as there can be several possible outputs.

#### t.start( )

```java
Thread t = new Thread();
Thread t1 = new Thread(r); // r is target runnable
t.start();
```

![[Pasted image 20240323124848.png]]

#### t1.start( )

```java
Thread t = new Thread();
Thread t1 = new Thread(r); // r is target runnable
t.start();
```

![[Pasted image 20240323124945.png]]

#### t.run( )

```java
Thread t = new Thread();
Thread t1 = new Thread(r); // r is target runnable
t.run();
```

![[Pasted image 20240323125702.png]]

#### t1.run( )

```java
Thread t = new Thread();
Thread t1 = new Thread(r); // r is target runnable
t1.run(); // Called before main thread's action

for (int i = 0; i < 3; i++) {
	System.out.println("main thread");
}
```

![[Pasted image 20240323125202.png]]

```java
Thread t = new Thread();
Thread t1 = new Thread(r); // r is target runnable
for (int i = 0; i < 3; i++) {
	System.out.println("main thread");
}

t1.run(); // Called after performing main thread's action
```

![[Pasted image 20240323125516.png]]

#### r.start( )

```java
Thread t = new Thread();
Thread t1 = new Thread(r); // r is target runnable
r.start()
```

![[Pasted image 20240323125922.png]]

#### r.run( )

```java
Thread t = new Thread();
Thread t1 = new Thread(r); // r is target runnable
r.run()
```

![[Pasted image 20240323130043.png]]

## Thread class Constructors

 1. Thread t=new Thread();
 2. Thread t=new Thread(Runnable r);
 3. Thread t=new Thread(String name);
 4. Thread t=new Thread(Runnable r,String name);

## Getting and Setting name of a Thread

Every Thread in java has some name. It’s name can be provided explicitly by the programmer or automatically generated by JVM.

### Methods used:

1. `public final void setName(String name)`
2. `public final String getName()`

```java
class MyThread extends Thread {

}

public class NamingThreads {
    public static void main(String[] args) {

        MyThread t = new MyThread();
        System.out.println(t.getName());

        System.out.println(Thread.currentThread().getName());

        t.setName("MyThread180");

        Thread.currentThread().setName("Main360");

        System.out.println(t.getName());
        System.out.println(Thread.currentThread().getName());

    }
}
```

![[Pasted image 20240323131236.png]]

## Thread Priorities

![[Pasted image 20240323131440.png]]
![[Pasted image 20240323131456.png]]
![[Pasted image 20240323131551.png]]
![[Pasted image 20240323132402.png]]

##### With user defined thread:

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread priority: " + this.getPriority());
    }
}

public class ThreadPriority {
    public static void main(String[] args) {

        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        // Getting default priority
        System.out.println("Default priority of t1: " + t1.getPriority());
        System.out.println("Default priority of t2: " + t2.getPriority());

        // Setting priority
        t1.setPriority(Thread.MIN_PRIORITY); // Setting minimum priority
        t2.setPriority(Thread.MAX_PRIORITY); // Setting maximum priority

        System.out.println("Priority of t1 after setting: " + t1.getPriority());
        System.out.println("Priority of t2 after setting: " + t2.getPriority());

        // Starting threads
        t1.start();
        t2.start();
    }
}
```

Output:

```yaml
Default priority of t1: 5
Default priority of t2: 5
Priority of t1 after setting: 1
Priority of t2 after setting: 10
Thread priority: 1
Thread priority: 10
```

#### With main thread:

```java
public class ThreadPriority {
    public static void main(String[] args) {

        // Getting default priority of the main thread
        System.out.println("Default priority of main thread: " + Thread.currentThread().getPriority());

        // Setting priority of the main thread
        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);

        // Printing priority of the main thread after setting
        System.out.println("Priority of main thread after setting: " + Thread.currentThread().getPriority());
    }
}
```

Output:

```YAML
Default priority of main thread: 5
Priority of main thread after setting: 10
```

![[Pasted image 20240323132537.png]]
![[Pasted image 20240323132601.png]]

## Methods to prevent a thread from execution

### 1. yield( )

`public static void yield()`

**yield()** method causes "to pause current executing Thread for giving the chance to remaining waiting Threads of same priority".

Suppose there are three threads t1, t2, and t3. Thread t1 gets the processor and starts its execution and thread t2 and t3 are in Ready/Runnable state. The completion time for thread t1 is 5 hours and the completion time for t2 is 5 minutes. Since t1 will complete its execution after 5 hours, t2 has to wait for 5 hours to just finish 5 minutes job. In such scenarios where one thread is taking too much time to complete its execution, we need a way to prevent the execution of a thread in between if something important is pending. yield() helps us in doing so. 

The **yield()** basically means that the thread is not doing anything particularly important and if any other threads or processes need to be run, they should run. Otherwise, the current thread will continue to run.

![[Pasted image 20240323152958.png]]

- Whenever a thread calls **java.lang.Thread.yield** method gives hint to the thread scheduler that it is ready to pause its execution. The thread scheduler is free to ignore this hint.
- If any thread executes the yield method, the thread scheduler checks if there is any thread with the same or high priority as this thread. If the processor finds any thread with higher or same priority then it will move the current thread to Ready/Runnable state and give the processor to another thread and if not – the current thread will keep executing.
- Once a thread has executed the yield method and there are many threads with the same priority is waiting for the processor, then we can’t specify which thread will get the execution chance first.
- The thread which executes the yield method will enter in the Runnable state from Running state.
- Once a thread pauses its execution, we can’t specify when it will get a chance again it depends on the thread scheduler.
- The underlying platform must provide support for preemptive scheduling if we are using the yield method.

![[Pasted image 20240323153044.png]]

### 2. sleep( )

sleep for the specified number of milliseconds
`public static void sleep(long millis)` throws `InterruptedException`

sleep for the specified number of milliseconds plus nano seconds
`public static void sleep(long millis, int nanos)` throws `InterruptedException`

- This method causes the currently executing thread to sleep for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers.
- If a Thread doesn't want to perform any operation for a particular amount of time then we should go for sleep() method.

![[Pasted image 20240323162847.png]]

```java
public class sleep implements Runnable {
    // Thread t;

    public void run() {
        for (int i = 0; i < 4; i++) {
            System.out.println(
                    Thread.currentThread().getName() + " " + i);
            try {
                // thread to sleep for 1000 milliseconds
                Thread.sleep(1000);
            }

            catch (Exception e) {
                System.out.println(e);
            }
        }
    }

    public static void main(String[] args) throws Exception {
        Thread t = new Thread(new sleep());

        // call run() function
        t.start();

        Thread t2 = new Thread(new sleep());

        // call run() function
        t2.start();
    }
}
```

